<html>
<head>
    <meta charset="utf-8" />
    <script src="https://unpkg.com/three@0.131.3/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.131.3/examples/js/controls/OrbitControls.js"></script>
    <script>
        // ページの読み込みを待つ
        window.addEventListener('load', init);

        function init() {



            // 毎フレーム時に実行されるループイベントです
            //function tick() {
            //    // レイキャスト = マウス位置からまっすぐに伸びる光線ベクトルを生成
            //    raycaster.setFromCamera(mouse, camera);

            //    // その光線とぶつかったオブジェクトを得る
            //    const intersects = raycaster.intersectObjects(meshList);

            //    meshList.map((mesh) => {
            //        // 交差しているオブジェクトが1つ以上存在し、
            //        // 交差しているオブジェクトの1番目(最前面)のものだったら
            //        if (intersects.length > 0 && mesh === intersects[0].object) {
            //            // 色を赤くする
            //            mesh.material.color.setHex(0xff0000);
            //        } else {
            //            // それ以外は元の色にする
            //            mesh.material.color.setHex(0xffffff);
            //        }
            //    });

            //    // レンダリング
            //    renderer.render(scene, camera);
            //    requestAnimationFrame(tick);
            //}


            // サイズを指定 *今は適当
            const width = 960;
            const height = 540;

            // canvas 要素の参照を取得する
            const canvas = document.querySelector('#myCanvas');
            // マウス座標管理用のベクトルを作成
            const mouse = new THREE.Vector2();
            const canvasElement = document.querySelector('#myCanvas');
            // レンダラーを作成
            //const renderer = new THREE.WebGLRenderer({
            //    canvas: canvasElement,
            //});
            //renderer.setSize(width, height);
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);

            // シーンを作成
            const scene = new THREE.Scene();

            // カメラを作成
            const camera = new THREE.PerspectiveCamera(45, width / height);
            // カメラの初期座標を設定
            camera.position.set(0, 0, 1000);

            // カメラコントローラーを作成
            const controls = new THREE.OrbitControls(camera, canvasElement);

            // 滑らかにカメラコントローラーを制御する
            controls.enableDamping = true;
            controls.dampingFactor = 0.2;

            // 平行光源を作成
            //const directionalLight = new THREE.DirectionalLight(0xffffff);
            //directionalLight.position.set(1, 1, 1);
            //scene.add(directionalLight);
            // 環境光源
            const ambientLight = new THREE.AmbientLight(0xffffff);
            ambientLight.position.set(1, 1, 1);
            scene.add(ambientLight);

            // シーンにメッシュを追加します
            const earthMesh = set_material('odaka/01_R0010010.JPG');
            scene.add(earthMesh);

            const earthMesh2 = set_material('odaka/01_R0010067.JPG');
            earthMesh2.position.x = 100;
            scene.add(earthMesh2);

            const earthMesh3 = set_material('odaka/01_R0010010.JPG');
            earthMesh3.position.x = 500;
            earthMesh3.position.z = -500;
            scene.add(earthMesh3);

            const earthMesh4 = set_material('odaka/01_R0010010.JPG');
            earthMesh4.position.x = 400;
            earthMesh4.position.z = -500;
            scene.add(earthMesh4);

            const earthMesh5 = set_material('odaka/01_R0010010.JPG');
            earthMesh5.position.x = 300;
            earthMesh5.position.z = -500;
            scene.add(earthMesh5);

            const earthMesh6 = set_material('odaka/01_R0010010.JPG');
            earthMesh6.position.x = 200;
            earthMesh6.position.z = -500;
            scene.add(earthMesh6);

            const earthMesh7 = set_material('odaka/01_R0010010.JPG');
            earthMesh7.position.x = 100;
            earthMesh7.position.z = -500;
            scene.add(earthMesh7);



            // 仮想視点のポイント
            //const geometry = new THREE.BoxBufferGeometry(50, 50, 50);
            const geometry = new THREE.CylinderGeometry(50, 50, 10, 32);
            const material = new THREE.MeshBasicMaterial({ color: 0x1F1FFF });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.x = 0;
            cylinder.position.z = -0;
            scene.add(cylinder);

            // マウスとの交差を調べたいものは配列に格納する
            const meshList = [];

            const material_mouse = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh_mouse = new THREE.Mesh(geometry, material_mouse);
            mesh_mouse.position.x = 0;
            mesh_mouse.position.y = 0;
            mesh_mouse.position.z = 0;
            scene.add(mesh_mouse);
            meshList.push(mesh_mouse);

            const material_mouse2 = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh_mouse2 = new THREE.Mesh(geometry, material_mouse2);
            mesh_mouse2.position.x = 500;
            mesh_mouse2.position.y = 0;
            mesh_mouse2.position.z = -500;
            scene.add(mesh_mouse2);
            meshList.push(mesh_mouse2);

            const material_mouse3 = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh_mouse3 = new THREE.Mesh(geometry, material_mouse3);
            mesh_mouse3.position.x = 400;
            mesh_mouse3.position.y = 0;
            mesh_mouse3.position.z = -500;
            scene.add(mesh_mouse3);
            meshList.push(mesh_mouse3);

            const material_mouse4 = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh_mouse4 = new THREE.Mesh(geometry, material_mouse4);
            mesh_mouse4.position.x = 300;
            mesh_mouse4.position.y = 0;
            mesh_mouse4.position.z = -500;
            scene.add(mesh_mouse4);
            meshList.push(mesh_mouse4);

            const material_mouse5 = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh_mouse5 = new THREE.Mesh(geometry, material_mouse5);
            mesh_mouse5.position.x = 200;
            mesh_mouse5.position.y = 0;
            mesh_mouse5.position.z = -500;
            scene.add(mesh_mouse5);
            meshList.push(mesh_mouse5);

            const material_mouse6 = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const mesh_mouse6 = new THREE.Mesh(geometry, material_mouse6);
            mesh_mouse6.position.x = 100;
            mesh_mouse6.position.y = 0;
            mesh_mouse6.position.z = -500;
            scene.add(mesh_mouse6);
            meshList.push(mesh_mouse6);




            // レイキャストを作成
            const raycaster = new THREE.Raycaster();
            canvas.addEventListener('mousemove', handleMouseMove);

            tick();

            // マウスを動かしたときのイベント
            function handleMouseMove(event) {
                const element = event.currentTarget;
                // canvas要素上のXY座標
                const x = event.clientX - element.offsetLeft;
                const y = event.clientY - element.offsetTop;
                // canvas要素の幅・高さ
                const w = element.offsetWidth;
                const h = element.offsetHeight;

                // -1〜+1の範囲で現在のマウス座標を登録する
                mouse.x = (x / w) * 2 - 1;
                mouse.y = -(y / h) * 2 + 1;
            }



            // 毎フレーム時に実行されるループイベントです
            function tick() {
                // 地球は常に回転させておく
                //earthMesh.rotation.y += 0.00001;

                // カメラコントローラーを更新
                controls.update();

                // レイキャスト = マウス位置からまっすぐに伸びる光線ベクトルを生成
                raycaster.setFromCamera(mouse, camera);

                //// その光線とぶつかったオブジェクトを得る
                const intersects = raycaster.intersectObjects(meshList);

                meshList.map((mesh) => {
                    // 交差しているオブジェクトが1つ以上存在し、
                    // 交差しているオブジェクトの1番目(最前面)のものだったら
                    if (intersects.length > 0 && mesh === intersects[0].object) {
                        // 色を赤くする
                        mesh.material.color.setHex(0xff0000);
                    } else {
                        // それ以外は元の色にする
                        mesh.material.color.setHex(0xffffff);
                    }
                });

                //// レンダリング
                renderer.render(scene, camera);
                requestAnimationFrame(tick);





            }
        }
        function set_material(file_name) {
            // マテリアルを作成
            const material = new THREE.MeshStandardMaterial({
                map: new THREE.TextureLoader().load(file_name),
                //裏面を描画
                side: THREE.BackSide
            });
            // 球体の形状を作成します
            const geometry = new THREE.SphereGeometry(300, 30, 30);
            // 形状とマテリアルからメッシュを作成します
            const earthMesh = new THREE.Mesh(geometry, material);
            // シーンにメッシュを追加します
            return earthMesh;
        }
        
    </script>
</head>
<body>
    <canvas id="myCanvas"></canvas>
</body>
</html>

